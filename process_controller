#!/usr/bin/env python3

import logging
import os
import sys
import time

from subprocess import call
from datetime import datetime, timedelta

logging.basicConfig(level=logging.INFO)

if len(sys.argv) != 3:
    print("usage: process_controller <working-directory> <auth-file>", file=sys.stderr)
    sys.exit(1)

working_directory = sys.argv[1]
auth_file = sys.argv[2]

os.chdir(working_directory)

while True:
    start = datetime.now()
    next_3am = datetime(start.year, start.month, start.day) + timedelta(days=1, hours=3)

    call(["git", "pull"])
    command_line = ['./start_frame', '--end-after', next_3am.strftime('%Y-%m-%d %H:%M:%S'), '--auth-file', auth_file]
    logging.info(f"Running command: {command_line}")
    exit_code = call(command_line)

    logging.info(f"Exited with code {exit_code}")
    if exit_code == 2:
        # user asked that we quit
        break

    # the program could have quit for a couple
    # reasons:
    # - it could have reached the --end-after
    #   date.  in that case, restart immediately
    # - the subprocess could have failed.  maybe
    #   the latest version of the code, downloaded
    #   from github, is broken
    #
    # either way, we want to resume the whole
    # git pull/run process. wait at least an hour
    # between runs, though, so wait until the
    # next hour before doing anything
    duration = datetime.now() - start
    time.sleep(max([0, 3600 - duration.total_seconds()]))
